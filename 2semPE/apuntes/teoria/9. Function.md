@ingroup apuntes-teoria

Las funciones son bloques de código reutilizables que encapsulan una tarea específica, promoviendo la modularidad, reutilización y mantenibilidad del código.

## Anatomía de una Función

### Estructura Básica
```c
// Declaración (prototipo) - en header o arriba
tipo_retorno nombre_funcion(tipo_parametro parametro);

// Definición - implementación
tipo_retorno nombre_funcion(tipo_parametro parametro) {
    // Cuerpo de la función
    return valor; // si tiene retorno
}

// Llamada
variable = nombre_funcion(argumento);
```

### Ejemplo Detallado
```c
#include <stdio.h>
#include <stdbool.h>

// Prototipo - interface pública
int calcular_potencia(int base, int exponente);

// Definición
int calcular_potencia(int base, int exponente) {
    int resultado = 1;
    for (int i = 0; i < exponente; i++) {
        resultado *= base;
    }
    return resultado;
}

int main() {
    int base = 2, exponente = 8;
    int potencia = calcular_potencia(base, exponente);
    printf("%d^%d = %d\n", base, exponente, potencia);
    return 0;
}
```

## Clasificación de Funciones

### 1. Función con Retorno y Parámetros
```c
// Función pura - sin efectos secundarios
float calcular_hipotenusa(float cateto_a, float cateto_b) {
    return sqrtf(cateto_a * cateto_a + cateto_b * cateto_b);
}
```

### 2. Función con Retorno sin Parámetros
```c
// Estado interno o entrada del usuario
int leer_entero_validado(void) {
    int valor;
    char buffer[100];
    
    while (1) {
        printf("Ingrese un número entero: ");
        if (fgets(buffer, sizeof(buffer), stdin) != NULL) {
            if (sscanf(buffer, "%d", &valor) == 1) {
                return valor;
            }
        }
        printf("Entrada inválida. Intente nuevamente.\n");
    }
}
```

### 3. Procedimiento (sin retorno con parámetros)
```c
void imprimir_tabla_multiplicar(int numero, int limite) {
    printf("Tabla de multiplicar del %d:\n", numero);
    for (int i = 1; i <= limite; i++) {
        printf("%d × %d = %d\n", numero, i, numero * i);
    }
}
```

### 4. Procedimiento sin Retorno ni Parámetros
```c
void mostrar_banner(void) {
    printf("=================================\n");
    printf("      SISTEMA DE GESTIÓN\n");
    printf("=================================\n");
    printf("Versión 2.1 - 2024\n\n");
}
```

## Paso de Parámetros

### Por Valor (Copia)
```c
void intercambiar_por_valor(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    // Los cambios son locales
}

int main() {
    int x = 5, y = 10;
    intercambiar_por_valor(x, y);
    printf("x=%d, y=%d\n", x, y); // x=5, y=10
    return 0;
}
```

### Por Referencia (Punteros)
```c
void intercambiar_por_referencia(int *a, int *b) {
    if (a == NULL || b == NULL) {
        fprintf(stderr, "Error: Punteros nulos\n");
        return;
    }
    
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    intercambiar_por_referencia(&x, &y);
    printf("x=%d, y=%d\n", x, y); // x=10, y=5
    return 0;
}
```

### Arrays como Parámetros
```c
// El array se pasa como puntero - se modifica el original
void inicializar_array(int arr[], int tamaño, int valor) {
    for (int i = 0; i < tamaño; i++) {
        arr[i] = valor;
    }
}

// Para evitar modificación accidental, usar const
double calcular_promedio(const int arr[], int tamaño) {
    if (tamaño <= 0) return 0.0;
    
    double suma = 0.0;
    for (int i = 0; i < tamaño; i++) {
        suma += arr[i];
    }
    return suma / tamaño;
}
```

## Ámbito y Duración de Variables

### Variables Locales
```c
void ejemplo_ambito(void) {
    int variable_local = 10; // Solo visible en esta función
    {
        int bloque_local = 20; // Solo visible en este bloque
        printf("Dentro del bloque: %d\n", bloque_local);
    }
    // printf("%d\n", bloque_local); // ERROR: no visible
}

// Cada llamada tiene su propia copia
int contador_local(void) {
    int count = 0; // Se reinicia en cada llamada
    count++;
    return count;
}
```

### Variables Estáticas
```c
int contador_estatico(void) {
    static int count = 0; // Persiste entre llamadas
    count++;
    return count;
}

int main() {
    printf("%d\n", contador_estatico()); // 1
    printf("%d\n", contador_estatico()); // 2
    printf("%d\n", contador_estatico()); // 3
    return 0;
}
```

### Variables Globales (Usar con precaución)
```c
// En el ámbito global - visible en todo el archivo
int contador_global = 0;

void incrementar_global(void) {
    contador_global++;
}

void mostrar_global(void) {
    printf("Contador global: %d\n", contador_global);
}
```

## Funciones Recursivas

### Ejemplo Básico: Factorial
```c
/**
 * Calcula el factorial de un número de forma recursiva
 * @param n: número entero no negativo
 * @return: n! factorial de n
 * @warning: n debe ser >= 0, no verifica overflow
 */
unsigned long long factorial_recursivo(unsigned int n) {
    // Caso base
    if (n == 0 || n == 1) {
        return 1;
    }
    // Caso recursivo
    return n * factorial_recursivo(n - 1);
}
```

### Ejemplo Avanzado: Fibonacci
```c
/**
 * Calcula el n-ésimo número de Fibonacci
 * Versión recursiva ineficiente para demostración
 */
long fibonacci_recursivo(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    return fibonacci_recursivo(n - 1) + fibonacci_recursivo(n - 2);
}

// Versión iterativa más eficiente
long fibonacci_iterativo(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    
    long a = 0, b = 1, resultado;
    for (int i = 2; i <= n; i++) {
        resultado = a + b;
        a = b;
        b = resultado;
    }
    return resultado;
}
```

## Manejo Robusto de Errores

### Códigos de Retorno Estándar
```c
#include <stdio.h>
#include <string.h>
#include <errno.h>

#define EXITO 0
#define ERROR_ARCHIVO -1
#define ERROR_MEMORIA -2
#define ERROR_ARGUMENTO -3

/**
 * Procesa un archivo de texto de forma segura
 * @param nombre_archivo: ruta del archivo a procesar
 * @param buffer: donde almacenar el contenido
 * @param tamaño_buffer: tamaño máximo del buffer
 * @return: EXITO (0) o código de error negativo
 */
int procesar_archivo(const char *nombre_archivo, char *buffer, size_t tamaño_buffer) {
    // Validación de parámetros
    if (nombre_archivo == NULL || buffer == NULL || tamaño_buffer == 0) {
        fprintf(stderr, "Error: Parámetros inválidos\n");
        return ERROR_ARGUMENTO;
    }
    
    // Apertura segura del archivo
    FILE *archivo = fopen(nombre_archivo, "r");
    if (archivo == NULL) {
        fprintf(stderr, "Error abriendo %s: %s\n", 
                nombre_archivo, strerror(errno));
        return ERROR_ARCHIVO;
    }
    
    // Lectura segura
    size_t bytes_leidos = fread(buffer, 1, tamaño_buffer - 1, archivo);
    buffer[bytes_leidos] = '\0'; // Null-terminator
    
    // Verificación de errores de lectura
    if (ferror(archivo)) {
        fprintf(stderr, "Error leyendo archivo: %s\n", strerror(errno));
        fclose(archivo);
        return ERROR_ARCHIVO;
    }
    
    fclose(archivo);
    return EXITO;
}
```

## Punteros a Funciones

### Concepto y Sintaxis
```c
#include <stdio.h>
#include <stdlib.h>

// Typedef para claridad
typedef int (*Comparador)(const void*, const void*);

// Funciones de comparación
int comparar_enteros_ascendente(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int comparar_enteros_descendente(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}

// Función que acepta puntero a función
void ordenar_array(int arr[], int tamaño, Comparador cmp) {
    qsort(arr, tamaño, sizeof(int), cmp);
}

void imprimir_array(const int arr[], int tamaño) {
    for (int i = 0; i < tamaño; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numeros[] = {5, 2, 8, 1, 9};
    int tamaño = sizeof(numeros) / sizeof(numeros[0]);
    
    printf("Original: ");
    imprimir_array(numeros, tamaño);
    
    ordenar_array(numeros, tamaño, comparar_enteros_ascendente);
    printf("Ascendente: ");
    imprimir_array(numeros, tamaño);
    
    ordenar_array(numeros, tamaño, comparar_enteros_descendente);
    printf("Descendente: ");
    imprimir_array(numeros, tamaño);
    
    return 0;
}
```

## Funciones Inline y Optimizaciones

### Función Inline
```c
#include <stdbool.h>

// Sugerencia al compilador para inline
static inline int max(int a, int b) {
    return (a > b) ? a : b;
}

static inline int min(int a, int b) {
    return (a < b) ? a : b;
}

static inline bool es_par(int n) {
    return (n & 1) == 0;
}
```

## Buenas Prácticas Profesionales

### 1. Nomenclatura y Estructura
```c
// MAL
void f(int x, int y) { ... }

// BIEN
void dibujar_circulo(int centro_x, int centro_y, int radio) {
    // Validación temprana
    if (radio <= 0) {
        fprintf(stderr, "Error: Radio debe ser positivo\n");
        return;
    }
    
    // Una responsabilidad por función
    calcular_y_dibujar_circunferencia(centro_x, centro_y, radio);
}
```

### 2. Validación de Parámetros
```c
#include <assert.h>

double calcular_raiz_cuadrada(double numero) {
    // Validación en modo debug
    assert(numero >= 0.0);
    
    // Validación en producción
    if (numero < 0.0) {
        fprintf(stderr, "Error: No existe raíz real de número negativo\n");
        return -1.0;
    }
    
    return sqrt(numero);
}
```

### 3. Documentación Profesional (Doxygen)
```c
/**
 * @brief Resuelve una ecuación cuadrática de la forma ax² + bx + c = 0
 * 
 * @param a Coeficiente cuadrático (no cero)
 * @param b Coeficiente lineal
 * @param c Término constante
 * @param raiz1 Puntero para almacenar la primera raíz
 * @param raiz2 Puntero para almacenar la segunda raíz
 * 
 * @return int Número de raíces reales encontradas:
 *             - 2: dos raíces reales distintas
 *             - 1: una raíz real doble
 *             - 0: raíces complejas
 *             - -1: error (a == 0)
 * 
 * @note Las raíces se almacenan en *raiz1 y *raiz2
 * @warning No verifica punteros nulos
 */
int resolver_ecuacion_cuadratica(double a, double b, double c, 
                                double *raiz1, double *raiz2) {
    if (a == 0.0) {
        return -1; // No es cuadrática
    }
    
    double discriminante = b * b - 4 * a * c;
    
    if (discriminante > 0) {
        *raiz1 = (-b + sqrt(discriminante)) / (2 * a);
        *raiz2 = (-b - sqrt(discriminante)) / (2 * a);
        return 2;
    } else if (discriminante == 0) {
        *raiz1 = *raiz2 = -b / (2 * a);
        return 1;
    } else {
        return 0; // Raíces complejas
    }
}
```

## Ejemplo Integrado: Sistema de Gestión

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_PRODUCTOS 100
#define MAX_NOMBRE 50

typedef struct {
    int id;
    char nombre[MAX_NOMBRE];
    float precio;
    int stock;
} Producto;

typedef struct {
    Producto productos[MAX_PRODUCTOS];
    int cantidad;
} Inventario;

// Prototipos
bool inicializar_inventario(Inventario *inv);
bool agregar_producto(Inventario *inv, const char *nombre, float precio, int stock);
bool actualizar_stock(Inventario *inv, int id, int nuevo_stock);
Producto* buscar_producto_por_id(const Inventario *inv, int id);
void imprimir_inventario(const Inventario *inv);
float calcular_valor_total_inventario(const Inventario *inv);

// Implementaciones
bool inicializar_inventario(Inventario *inv) {
    if (inv == NULL) return false;
    
    inv->cantidad = 0;
    memset(inv->productos, 0, sizeof(inv->productos));
    return true;
}

bool agregar_producto(Inventario *inv, const char *nombre, float precio, int stock) {
    if (inv == NULL || nombre == NULL || inv->cantidad >= MAX_PRODUCTOS) {
        return false;
    }
    
    Producto *nuevo = &inv->productos[inv->cantidad];
    nuevo->id = inv->cantidad + 1;
    strncpy(nuevo->nombre, nombre, MAX_NOMBRE - 1);
    nuevo->nombre[MAX_NOMBRE - 1] = '\0';
    nuevo->precio = precio;
    nuevo->stock = stock;
    
    inv->cantidad++;
    return true;
}

void imprimir_inventario(const Inventario *inv) {
    if (inv == NULL) return;
    
    printf("\n=== INVENTARIO (%d productos) ===\n", inv->cantidad);
    printf("%-4s %-20s %-10s %-6s\n", "ID", "Nombre", "Precio", "Stock");
    printf("----------------------------------------\n");
    
    for (int i = 0; i < inv->cantidad; i++) {
        const Producto *p = &inv->productos[i];
        printf("%-4d %-20s $%-9.2f %-6d\n", 
               p->id, p->nombre, p->precio, p->stock);
    }
}

int main() {
    Inventario inv;
    
    if (!inicializar_inventario(&inv)) {
        fprintf(stderr, "Error inicializando inventario\n");
        return EXIT_FAILURE;
    }
    
    // Agregar productos de ejemplo
    agregar_producto(&inv, "Laptop Gaming", 1200.99, 5);
    agregar_producto(&inv, "Mouse Inalámbrico", 25.50, 20);
    agregar_producto(&inv, "Teclado Mecánico", 89.99, 15);
    
    imprimir_inventario(&inv);
    
    printf("\nValor total del inventario: $%.2f\n", 
           calcular_valor_total_inventario(&inv));
    
    return EXIT_SUCCESS;
}

float calcular_valor_total_inventario(const Inventario *inv) {
    if (inv == NULL) return 0.0f;
    
    float total = 0.0f;
    for (int i = 0; i < inv->cantidad; i++) {
        total += inv->productos[i].precio * inv->productos[i].stock;
    }
    return total;
}
```

## Consejos Finales

1. **Cohesión**: Cada función debe tener una sola responsabilidad
2. **Acoplamiento**: Minimizar dependencias entre funciones
3. **Longitud**: Idealmente menos de 50 líneas por función
4. **Complejidad**: Evitar anidamiento profundo (máximo 3-4 niveles)
5. **Pruebas**: Escribir funciones fáciles de probar unitariamente
6. **Documentación**: Documentar interfaces, no implementaciones
7. **Error Handling**: Manejar errores de forma consistente
8. **Performance**: Perfilar antes de optimizar