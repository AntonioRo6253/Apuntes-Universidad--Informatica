@ingroup apuntes-teoria

En programación en C, la programación modular significa dividir el código en partes más pequeñas y reutilizables. Esto hace que su código sea más fácil de leer, mantener y depurar, Cada módulo tipicamente contiene funciones y variables relacionadas, y se implementa en **archivos separados** (`.c` y `.h`).

**Ejemplo***
En doom 1993 el archivo de cabecera [d_player.h](https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/d_player.h) declara la estructura de tipo `enum` con el miembro playerstate_t (PST_LIVE, PST_DEAD, PST_REBORN). el cual se usa en [p_user.c](https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/p_user.c) para controlar el comportamiento del jugador según su estado (vivo`PST_LIVE`, muerto`PST_DEAD` o listo para reaparecer`PST_REBORN`).

## **Elementos clave y sintaxis**:
1. **Archivos de cabecera (`.h`)**  
   - Declaraciones de funciones, constantes, estructuras, tipos de datos y variables globales (usando `extern`).  
   - **Sintaxis**:
```c
     // ejemplo.h
     #ifndef EJEMPLO_H  // Guardas para evitar inclusiones múltiples
     #define EJEMPLO_H
     
     // Declaración de función
     int sumar(int a, int b);
     
     // Declaración de variable global
     extern int contador;
     #endif
```

2. **Archivos fuente (`.c`)**  
   - Implementación de las funciones declaradas en los archivos `.h`.  
   - **Sintaxis**:
```c
     // ejemplo.c
     #include "ejemplo.h"
     
     int contador = 0;  // Definición de la variable global
     
     // Implementación de la función
     int sumar(int a, int b) {
         contador++;
         return a + b;
     }
```

3. **Inclusión de módulos**  
   - Usando `#include "archivo.h"` para acceder a las declaraciones.
   - **Sintaxis**:
```c
     // main.c
     #include "ejemplo.h"
     
     int main() {
         int resultado = sumar(5, 3); // Usa la función del módulo
         return 0;
     }
```

4. **Compilación modular**  
   - Compila cada archivo `.c` por separado y luego enlázalos:
```bash
     gcc -c ejemplo.c -o ejemplo.o
     gcc -c main.c -o main.o
     gcc ejemplo.o main.o -o programa
```

---

### **Ejemplo de estructura**:
```
proyecto/
│
├── math_ops.h     // Declaraciones de operaciones matemáticas
├── math_ops.c     // Implementación de funciones
├── main.c         // Programa principal
└── Makefile       // Automatización de compilación
```

## Makefile
**Documentacion:** [Red Hat](https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/8/html/developing_c_and_cpp_applications_in_rhel_8/example-building-a-c-program-using-a-makefile_managing-more-code-with-make)
Es un archivo esencial en C (y otros lenguajes) que define **instrucciones de construcción** para tu proyecto. Es el "manual de instrucciones" que le dice al sistema cómo compilar tu código.
**Sintaxis**
```makefile
#-------- VARIABLES --------
# Compilador
CC = gcc
# Opciones de compilación
CFLAGS = -c -Wall
# Nombre del ejecutable
TARGET = mi_programa
# Archivos fuente (puedes añadir más separados por espacios)
SOURCES = hello.c
# Archivos objeto (se generan automáticamente de los .c)
OBJECTS = $(SOURCES:.c=.o)

#-------- REGLAS --------
all: $(TARGET)
	
$(TARGET): $(OBJECTS)
	$(CC) $^ -o $@
	
# Regla genérica para compilar cada .c a .o
%.o: %.c
	$(CC) $(CFLAGS) $< -o $@
	
# Instala el programa (ejemplo)
install:
	cp $(TARGET) /usr/local/bin/
	
# Limpieza de archivos generados
clean:
	rm -rf $(OBJECTS) $(TARGET)
	
# Declaración de objetivos falsos
.PHONY: all clean
```