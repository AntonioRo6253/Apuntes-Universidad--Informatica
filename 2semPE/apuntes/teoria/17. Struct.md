
@ingroup apuntes-teoria
**Documentacion:** [Microsoft](https://learn.microsoft.com/es-es/cpp/cpp/struct-cpp?view=msvc-170) | [cppReference](https://en.cppreference.com/w/c/language/struct.html) | [IBM](https://www.ibm.com/docs/en/zos/2.5.0?topic=interface-c-structures) | [GNU](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Structures.html)
**Tutoriales:**
- [Structs y typedef en C - Curso de programación en C PASO a PASO (28)](https://www.youtube.com/watch?v=49hn2gdRhoo)
- [C structs 🏠](https://www.youtube.com/watch?v=oKXP1HZ8xIs)
**Libros:**
- [Programación en C, C++, Java y UML Luis Joyanes Aguilar{2Edicion}](https://www.mheducation.com.mx/programacion-en-c-c-java-y-uml-9786071512123-latam) 280, 285, 287, 288, 291, 292, 293
- [C/C++ Como Programar{4Edicion}]() 355-361

Una **estructura** es una colección de variables (llamadas **miembros**) que pueden ser de diferentes tipos de datos, agrupadas bajo un nombre común en un bloque de memoria contiguo. Son fundamentales para organizar datos relacionados y crear tipos de datos complejos.


**Características clave:**
- Agrupan datos heterogéneos bajo un mismo nombre
- Ocupan memoria contigua para todos sus miembros
- No incluyen métodos (funciones) como en otros lenguajes
- También se conocen como _"registros"_ en algunos contextos

## Sintaxis Básica y Declaración

### Definición de Estructuras
**concepto**
```c
/* DEFINIR */
struct estructura { 
	tipo miembro1;
	tipo miembro2;
    // ...
}
/* USAR */
void funcion(){ 
	struct estructura miEstructura; // estructura persona
	miEstructura.miembro1; // llamar un miembro
}
```
---

```c
#include <stdio.h>
#include <string.h>

/* DEFINICIÓN GLOBAL de la estructura */
struct jugador {           // `struct` + nombre_estructura
    int nivel;             // Miembro de tipo entero
    char nombre[50];       // Miembro: arreglo de caracteres
    float salud;           // Miembro de tipo flotante
}; // ¡No olvidar el punto y coma!

/* DECLARACIÓN de variables de estructura */
int main() {
    /* Variables normales de estructura */
    struct jugador jugador1, jugador2; // En C puro, se requiere `struct`
    
    /* Acceso a miembros con operador punto (.) */
    strcpy(jugador1.nombre, "Memo");
    jugador1.nivel = 35;
    jugador1.salud = 100.0f;
    
    /* Acceso con punteros usando operador flecha (->) */
    struct jugador *ptr = &jugador2;
    strcpy(ptr->nombre, "Ana");
    ptr->nivel = 28;
    ptr->salud = 85.5f;
    
    return 0;
}
```
**Ejemplo de clase**
> nota
```c
struct empleado {
    int codigo;
    char nombre[40]; // nombre completo
    float salario;
};
int main(){
   /* definir varios en uno */
    struct empleado empleados[3] = {
        {12324,"pedro",1500}, // empleado1
        {12314,"memo",1200}, // empleado2
        {11024,"maria",1000}
    }; // arreglo de estructuras

    /* definir uno por uno */
    struct empleado empleado2;
    struct empleado empleado2;
    struct empleado empleado3;
    return 0;
}
```

### Declaración Global

**concepto**
```c
// Define la estructura y variables globales en una sola declaración.
struct Jugador { int nivel; } jugador1, jugador2;
```

```c
/* DEFINICIÓN con declaración inmediata de variables globales */
struct jugador {
    int nivel;
    char nombre[50];
} jugador1, jugador2, jugador3; // Variables globales

int main() {
    // Estas variables son accesibles en toda la función main
    strcpy(jugador1.nombre, "Jugador Global");
    jugador1.nivel = 10;
    
    return 0;
}
```

**Consideraciones de ámbito:**
- Las estructuras definidas fuera de funciones tienen ámbito global
- Las variables declaradas junto con la definición son globales
- Para uso local, definir la estructura globalmente y declarar variables dentro de funciones

## Métodos de Inicialización

**concepto**
```c
// Puedes rellenar la estructura al declararla para dejarla lista desde el inicio.
struct Tipo dato = {.campo = valor};
```

### 1. Inicialización Designada (C99+) - **RECOMENDADA**

```c
#include <stdio.h>
#include <string.h>

struct jugador {
    int nivel;
    char nombre[50];
    int salud;
};

int main() {
    /* Inicialización designada - orden independiente */
    struct jugador jugador1 = {
        .nivel = 35,
        .nombre = "Memo",  // Para literales de string
        .salud = 100
    };
    
    struct jugador jugador2 = {
        .nombre = "Ana",   // Puede ir en cualquier orden
        .salud = 80,
        .nivel = 28
    };
    
    printf("Jugador: %s, Nivel: %d, Salud: %d\n", 
           jugador1.nombre, jugador1.nivel, jugador1.salud);
    
    return 0;
}
```

**Ventajas de la inicialización designada:**
- Orden independiente de los miembros
- Código más legible y auto-documentado
- Puedes omitir miembros (se inicializan a 0 automáticamente)
- Menos propenso a errores al modificar la estructura

### 2. Inicialización Posicional (Clásica)

```c
struct jugador jugador3 = {15, "Juan", 50}; // Orden: nivel, nombre, salud
```

**Precaución:** El orden debe coincidir exactamente con la declaración de la estructura.

### 3. Inicialización Parcial y Cero

```c
/* Inicialización parcial - miembros faltantes se ponen a 0 */
struct jugador jugador4 = {
    .nivel = 10,
    .nombre = "Nuevo"
    // salud se inicializa automáticamente a 0
};

/* Inicialización cero - todos los miembros a 0 */
struct jugador jugador5 = {0};
struct jugador jugador6 = {}; // C99+, equivalente a {0}
```

## Modificación de Estructuras

**concepto**
```c
// Usa . para variables y -> para punteros al acceder y modificar miembros.
jugador.nivel = 10;
ptr->salud = 90;
```

```c
#include <stdio.h>
#include <string.h>

struct jugador {
    int nivel;
    char nombre[50];
    int inventario[2][3];
    int salud;
};

int main() {
    struct jugador jugador1 = {
	    .nombre = "Inicial", 
	    .nivel = 1,
	    .inventario = {
		    {123,234,283},
		    {246,276,297}
		}, 
	    .salud = 100
	};
    
    /* Modificación de variables normales */
    strcpy(jugador1.nombre, "Luis");  // Cambiar string
    jugador1.nivel = 99;              // Cambiar número
    
    int nuevo_inventario[2][3] = {
	    {1, 2, 3}, 
	    {4, 5, 6}
	};// cambiar matriz
	memcpy(jugador1.inventario,nuevoInven,sizeof(jugador1.inventario));
	
    jugador1.salud = 150;
    
    /* Modificación mediante punteros */
    struct jugador *ptr = &jugador1;
    strcpy(ptr->nombre, "María");     // Usar -> con punteros
    ptr->nivel = 10;
    ptr->salud = 75;
    
    return 0;
}
```

## Uso de `typedef` con Estructuras

**concepto**
```c
// typedef crea un alias de tipo para no repetir la palabra struct cada vez.
typedef struct { int nivel; } Jugador;
Jugador heroe;
```

```c
#include <stdio.h>
#include <string.h>

/* Método 1: typedef con estructura definida por separado */
struct jugador_struct {
    int nivel;
    char nombre[50];
};
typedef struct jugador_struct Jugador; // Alias

/* Método 2: typedef combinado con definición (MÁS COMÚN) */
typedef struct {
    int nivel;
    char nombre[50];
    int salud;
} Jugador; // ¡Jugador es ahora un tipo!

/* Método 3: Para estructuras que se autorreferencian */
typedef struct nodo {
    int valor;
    struct nodo *siguiente; // Aquí necesitamos 'struct nodo'
} Nodo;

int main() {
    Jugador jugador1; // ¡Sin 'struct'!
    jugador1.nivel = 10;
    strcpy(jugador1.nombre, "Ejemplo");
    jugador1.salud = 100;
    
    Nodo primer_nodo = {5, NULL};
    
    return 0;
}
```

**Ventajas de typedef:**
- Código más limpio y legible
- No requiere repetir `struct`
- Facilita el mantenimiento
- Mejor abstracción de datos

**Consideraciones:**
- En estructuras autorreferenciadas (como listas enlazadas), se debe usar el nombre completo `struct nombre` dentro de la definición

## Estructuras Anidadas

**concepto**
```c
// Una estructura puede contener otras para encapsular datos relacionados.
typedef struct { struct Jugador info; struct Posicion lugar; } Entidad;
```

### Uso con `typedef` (Recomendado)

```c
#include <stdio.h>
#include <string.h>

/* Definir estructuras base con typedef */
typedef struct {
    int nivel;
    char nombre[50];
    float salud;
} Jugador;

typedef struct {
    int x;
    int y;
} Posicion;

/* Estructura que contiene otras estructuras */
typedef struct {
    Jugador jugador;        // Estructura anidada
    Posicion posicion;      // Otra estructura anidada
    int zona_actual;
} EntidadJugador;

int main() {
    /* Declaración y acceso anidado */
    EntidadJugador heroe;
    
    strcpy(heroe.jugador.nombre, "Guerrero");
    heroe.jugador.nivel = 15;
    heroe.jugador.salud = 95.5f;
    heroe.posicion.x = 100;
    heroe.posicion.y = 200;
    heroe.zona_actual = 3;
    
    printf("%s está en posición (%d, %d)\n", 
           heroe.jugador.nombre, heroe.posicion.x, heroe.posicion.y);
    
    return 0;
}
```

### Inicialización de Estructuras Anidadas

```c
/* Inicialización designada para estructuras anidadas */
EntidadJugador enemigo = {
    .jugador = {
        .nombre = "Orco",
        .nivel = 5,
        .salud = 75.0f
    },
    .posicion = {
        .x = 150,
        .y = 180
    },
    .zona_actual = 3
};

/* Inicialización posicional (menos legible) */
EntidadJugador npc = {
    {"NPC", 2, 50.0f},  // jugador
    {50, 75},           // posicion  
    1                   // zona_actual
};
```

## Arreglos en Estructuras

**concepto**
```c
// Los arreglos ocupan memoria dentro de la estructura; los punteros apuntan fuera.
char nombre[32];
char *alias;
```

### Punteros vs. Arreglos: Diferencias Clave

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_TITULO 100
#define MAX_EDITORIAL 50

typedef struct {
    /* DIFERENCIAS CRÍTICAS: */
    char titulo[MAX_TITULO];    // 1. Arreglo: memoria incluida en la estructura
    char *autor;               // 2. Puntero: memoria externa, debe asignarse
    char editorial[MAX_EDITORIAL];
    int año;
    float precio;
} Libro;

int main() {
    Libro libro1;
    
/* PARA ARREGLOS: usar strcpy/strncpy/snprintf */
    strncpy(libro1.titulo, "Programación en C", MAX_TITULO - 1);
    libro1.titulo[MAX_TITULO - 1] = '\0'; // Asegurar terminación nula
    
    /* Metodo mas seguro: snprintf */
    snprintf(libro1.editorial, MAX_EDITORIAL, "Editorial Técnica");
    
/* PARA PUNTEROS: asignación directa (literales) */
    libro1.autor = "Luis Joyanes"; // Solo para literales de string
    
    /* PARA PUNTEROS: asignación dinámica (strings variables) */
    char nombre_autor[] = "Ana García";
    libro1.autor = malloc(strlen(nombre_autor) + 1);
    if (libro1.autor != NULL) {
        strcpy(libro1.autor, nombre_autor);
    }
    
    libro1.año = 2024;
    libro1.precio = 45.99f;
    
    /* ¡IMPORTANTE: Liberar memoria asignada dinámicamente! */
    if (libro1.autor != NULL && libro1.autor != "Luis Joyanes") {
        free(libro1.autor);
    }
    
    return 0;
}
```

### Ejemplo Completo con Arreglos de Estructuras

```c
#include <stdio.h>
#include <string.h>

#define NUM_LIBROS 3

typedef struct {
    char titulo[100];
    char autor[50];
    int año;
} Libro;

int main() {
    /* Inicialización de arreglo de estructuras */
    Libro biblioteca[NUM_LIBROS] = {
        {"C Programming Language", "Kernighan & Ritchie", 1978},
        {"Effective C", "Robert Seacord", 2020},
        {"Modern C", "Jens Gustedt", 2019}
    };
    
    /* Inicialización designada para arreglos */
    Libro libros_designados[NUM_LIBROS] = {
        {.titulo = "Libro A", .autor = "Autor A", .año = 2000},
        {.titulo = "Libro B", .autor = "Autor B", .año = 2010},
        {.titulo = "Libro C", .autor = "Autor C", .año = 2020}
    };
    
    /* Recorrer arreglo de estructuras */
    for (int i = 0; i < NUM_LIBROS; i++) {
        printf("Libro %d: %s por %s (%d)\n", 
               i + 1, 
               biblioteca[i].titulo, 
               biblioteca[i].autor, 
               biblioteca[i].año);
    }
    
    return 0;
}
```

## Estructuras como Parámetros de Funciones

**concepto**
```c
// Pasar referencias evita copias grandes y permite modificar el original.
void actualizar(miEstructura *miembro){
miEstructura -> *miembro = 0;
};
```

### Paso por Referencia vs. Paso por Valor

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    int nivel;
    char nombre[50];
    float salud;
    int experiencia;
} Jugador;

/* PASO POR REFERENCIA (RECOMENDADO) */
void subirNivel(Jugador *jugador) {
    if (jugador == NULL) return;
    
    jugador->nivel++;
    jugador->salud += 10.0f;
    jugador->experiencia = 0;
    
    printf("%s subió al nivel %d!\n", jugador->nombre, jugador->nivel);
}

/* PASO POR VALOR (copia toda la estructura) */
Jugador crearCopia(Jugador original) {
    /* Modificaciones afectan solo a la copia */
    original.nivel = 1; // No afecta al original
    return original;    // Retorna nueva copia
}

/* PASO POR REFERENCIA CONSTANTE (solo lectura) */
void mostrarJugador(const Jugador *jugador) {
    if (jugador == NULL) return;
    
    printf("=== ESTADÍSTICAS ===\n");
    printf("Nombre: %s\n", jugador->nombre);
    printf("Nivel: %d\n", jugador->nivel);
    printf("Salud: %.1f\n", jugador->salud);
    printf("Experiencia: %d\n", jugador->experiencia);
}

/* FUNCIÓN QUE RETORNA ESTRUCTURA */
Jugador crearJugador(const char *nombre, int nivel_inicial) {
    Jugador nuevo = {
        .nivel = nivel_inicial,
        .salud = nivel_inicial * 10.0f,
        .experiencia = 0
    };
    
    // Copiar nombre de forma segura
    strncpy(nuevo.nombre, nombre, sizeof(nuevo.nombre) - 1);
    nuevo.nombre[sizeof(nuevo.nombre) - 1] = '\0';
    
    return nuevo; // Retorna por valor (copia)
}

int main() {
    Jugador heroe = crearJugador("Héroe", 1);
    
    /* Paso por referencia */
    subirNivel(&heroe);
    
    /* Paso por referencia constante (solo lectura) */
    mostrarJugador(&heroe);
    
    /* Paso por valor - crea copia */
    Jugador copia = crearCopia(heroe);
    mostrarJugador(&copia);
    
    return 0;
}
```

## Asignación y Comparación de Estructuras

**concepto**
```c
// Asignar copia toda la estructura; comparar requiere revisar cada miembro.
miEstructura1 = miEstructura2;
bool iguales = (miEstructura1.miembro == miEstructura2.miembro);
```

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

typedef struct {
    int x;
    int y;
} Punto;

int main() {
    Punto p1 = {10, 20};
    Punto p2, p3;
    
    /* ASIGNACIÓN DIRECTA (C99+) */
    p2 = p1; // Copia todos los miembros
    
    printf("p1: (%d, %d)\n", p1.x, p1.y);
    printf("p2: (%d, %d)\n", p2.x, p2.y);
    
    /* COMPARACIÓN - NO se puede usar == */
    // ❌ INCORRECTO: if (p1 == p2) 
    
    /* ✅ CORRECTO: comparar miembro por miembro */
    bool son_iguales = (p1.x == p2.x && p1.y == p2.y);
    printf("Los puntos %s iguales\n", son_iguales ? "son" : "no son");
    
    /* Usar memcpy para copias más controladas */
    memcpy(&p3, &p1, sizeof(Punto));
    printf("p3: (%d, %d)\n", p3.x, p3.y);
    
    return 0;
}
```

## Mejores Prácticas y Consideraciones de Rendimiento

**concepto**
```c
// Ordenar los miembros por tamaño reduce padding y mejora el uso de memoria.
struct Producto { int id; float precio; char nombre[32]; };
```

### Diseño de Estructuras Eficientes

```c
#include <stdio.h>
#include <stddef.h> // para offsetof

/* BUEN DISEÑO: miembros alineados naturalmente */
typedef struct {
    int id;           // 4 bytes
    float precio;     // 4 bytes  
    char nombre[32];  // 32 bytes
} Producto;           // Total: ~40 bytes, bien alineado

/* MAL DISEÑO: mezcla sin considerar alineación */
typedef struct {
    char letra;       // 1 byte (+3 padding)
    int numero;       // 4 bytes
    char simbolo;     // 1 byte (+3 padding)
} EstructuraIneficiente; // Total: 12 bytes (¡solo 6 útiles!)

void mostrarTamaños() {
    printf("Tamaño de Producto: %zu bytes\n", sizeof(Producto));
    printf("Tamaño de EstructuraIneficiente: %zu bytes\n", 
           sizeof(EstructuraIneficiente));
    
    /* Mostrar offsets de miembros */
    printf("Offset de 'id' en Producto: %zu\n", offsetof(Producto, id));
    printf("Offset de 'precio' en Producto: %zu\n", offsetof(Producto, precio));
}
```

### Gestión de Memoria para Estructuras

**concepto**
```c
// Si guardas punteros
perfil->nombre = malloc(...); // reserva 
free(perfil->nombre); // libera memoria de manera explícita.
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *nombre;      // Memoria dinámica
    int *puntuaciones; // Arreglo dinámico
    int num_puntuaciones;
} PerfilJugador;

PerfilJugador* crearPerfil(const char *nombre, int capacidad_puntuaciones) {
    PerfilJugador *nuevo = malloc(sizeof(PerfilJugador));
    if (nuevo == NULL) return NULL;
    
    /* Asignar memoria para el nombre */
    nuevo->nombre = malloc(strlen(nombre) + 1);
    if (nuevo->nombre == NULL) {
        free(nuevo);
        return NULL;
    }
    strcpy(nuevo->nombre, nombre);
    
    /* Asignar memoria para arreglo de puntuaciones */
    nuevo->puntuaciones = malloc(capacidad_puntuaciones * sizeof(int));
    if (nuevo->puntuaciones == NULL) {
        free(nuevo->nombre);
        free(nuevo);
        return NULL;
    }
    
    nuevo->num_puntuaciones = 0;
    return nuevo;
}

void liberarPerfil(PerfilJugador *perfil) {
    if (perfil != NULL) {
        free(perfil->nombre);       // Liberar string
        free(perfil->puntuaciones); // Liberar arreglo
        free(perfil);               // Liberar estructura
    }
}
```

## Ejemplo Completo: Sistema de Gestión

**concepto**
```c
// Aplica todas las ideas: estructuras, arreglos y funciones trabajando juntas.
```

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_ESTUDIANTES 100
#define MAX_NOMBRE 50

typedef struct {
    int id;
    char nombre[MAX_NOMBRE];
    float calificaciones[3];
    float promedio;
} Estudiante;

typedef struct {
    Estudiante estudiantes[MAX_ESTUDIANTES];
    int cantidad;
    char curso[50];
} Grupo;

void inicializarGrupo(Grupo *grupo, const char *nombre_curso) {
    grupo->cantidad = 0;
    strncpy(grupo->curso, nombre_curso, sizeof(grupo->curso) - 1);
    grupo->curso[sizeof(grupo->curso) - 1] = '\0';
}

int agregarEstudiante(Grupo *grupo, const char *nombre, 
                      float calif1, float calif2, float calif3) {
    if (grupo->cantidad >= MAX_ESTUDIANTES) {
        return -1; // Grupo lleno
    }
    
    Estudiante *nuevo = &grupo->estudiantes[grupo->cantidad];
    nuevo->id = grupo->cantidad + 1;
    
    strncpy(nuevo->nombre, nombre, MAX_NOMBRE - 1);
    nuevo->nombre[MAX_NOMBRE - 1] = '\0';
    
    nuevo->calificaciones[0] = calif1;
    nuevo->calificaciones[1] = calif2;
    nuevo->calificaciones[2] = calif3;
    
    nuevo->promedio = (calif1 + calif2 + calif3) / 3.0f;
    
    return grupo->cantidad++; // Retorna índice y luego incrementa
}

void mostrarGrupo(const Grupo *grupo) {
    printf("=== GRUPO: %s ===\n", grupo->curso);
    printf("Total estudiantes: %d\n\n", grupo->cantidad);
    
    for (int i = 0; i < grupo->cantidad; i++) {
        const Estudiante *est = &grupo->estudiantes[i];
        printf("ID: %d, Nombre: %s\n", est->id, est->nombre);
        printf("Calificaciones: %.1f, %.1f, %.1f\n", 
               est->calificaciones[0], 
               est->calificaciones[1], 
               est->calificaciones[2]);
        printf("Promedio: %.2f\n\n", est->promedio);
    }
}

int main() {
    Grupo matematicas;
    
    inicializarGrupo(&matematicas, "Matemáticas Avanzadas");
    
    agregarEstudiante(&matematicas, "Ana García", 85.5f, 90.0f, 88.5f);
    agregarEstudiante(&matematicas, "Luis Martínez", 78.0f, 82.5f, 79.0f);
    agregarEstudiante(&matematicas, "María López", 92.0f, 95.5f, 91.0f);
    
    mostrarGrupo(&matematicas);
    
    return 0;
}
```

## Errores Comunes y Cómo Evitarlos

### 1. Olvidar el punto y coma
```c
// ❌ INCORRECTO
struct ejemplo {
    int a;
    char b;
} // Falta ;

// ✅ CORRECTO  
struct ejemplo {
    int a;
    char b;
};
```

### 2. Confundir operadores . y ->
```c
struct punto { int x, y; } p;
struct punto *ptr = &p;

// ❌ INCORRECTO
ptr.x = 10;   // ptr es puntero, usa ->
(*ptr).x = 10; // Funciona pero verboso

// ✅ CORRECTO
ptr->x = 10;  // Sintaxis clara y concisa
```

### 3. Asignación incorrecta de strings
```c
struct persona {
    char nombre[50];
    char *apellido;
} p;

// ❌ INCORRECTO
p.nombre = "Juan";   // No se puede asignar a arreglos

// ✅ CORRECTO  
strcpy(p.nombre, "Juan");     // Para arreglos
p.apellido = "Pérez";         // Para punteros (solo literales)
```

### 4. No verificar punteros nulos
```c
void procesarJugador(struct jugador *j) {
    // ❌ PELIGROSO
    j->nivel = 10; // Crash si j es NULL
    
    // ✅ SEGURO
    if (j != NULL) {
        j->nivel = 10;
    }
}
```

**Recomendaciones finales:**
1. Usa `typedef` para código más limpio
2. Prefiere inicialización designada (C99+)
3. Usa paso por referencia para estructuras grandes
4. Siempre verifica punteros antes de acceder a miembros
5. Considera el padding y alineación para estructuras críticas en rendimiento