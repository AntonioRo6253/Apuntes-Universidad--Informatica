@ingroup apuntes-teoria
# Punteros
## 1. ¿Qué es un puntero?

Un puntero es una variable que almacena la dirección de memoria de otra variable. En lugar de guardar un valor directamente (como un número o carácter), guarda la ubicación donde ese valor está almacenado en la memoria.

· Sintaxis para declarar un puntero:
  ```c
  tipo_dato *nombre_puntero;
  ```
  Ejemplo:
  ```c
  int *ptr;  // Puntero a un entero
  ```

### [video Introduccion a Pointers artefisual](https://youtube.com/shorts/dndTtE2KQ6Y?si=385bUFzDFkh58fnk)

![[Screenshot_20250925-140645.png|200]]

![[Screenshot_20250925-140654.png|200]]

---

## 2. El operador & (dirección de)

El operador & se usa para obtener la dirección de memoria de una variable.

· Ejemplo:
  ```c
  int num = 10;
  printf("Dirección de num: %p", &num);  // Imprime la dirección de memoria de num
  ```

---

## 3. Cómo usar punteros

a) Asignar una dirección a un puntero:

```c
int num = 10;
int *ptr = &num;  // ptr ahora almacena la dirección de num
```

b) Acceder al valor apuntado (operador *):

El operador * se usa para acceder al valor almacenado en la dirección a la que apunta el puntero (esto se llama "desreferenciar").

```c
printf("Valor de num: %d", *ptr);  // Imprime 10
```

c) Modificar el valor a través del puntero:

```c
*ptr = 20;  // Cambia el valor de num a 20
printf("Nuevo valor de num: %d", num);  // Imprime 20
```

---

4. Ejemplo completo

```c
#include <stdio.h>

int main() {
    int num = 10;
    int *ptr = &num;  // ptr guarda la dirección de num

    printf("Valor de num: %d\n", num);        // 10
    printf("Dirección de num: %p\n", &num);   // Dirección de num
    printf("Valor de ptr: %p\n", ptr);        // Misma dirección que &num
    printf("Valor apuntado por ptr: %d\n", *ptr); // 10

    *ptr = 30;  // Modificamos num a través de ptr
    printf("Nuevo valor de num: %d\n", num);  // 30

    return 0;
}
```

---

5. Casos de uso comunes

· Pasar variables por referencia a funciones (para modificarlas dentro de la función).
· Trabajar con arrays y strings de manera eficiente.
· Asignación dinámica de memoria (con malloc, calloc, etc.).
· Estructuras de datos complejas (listas, árboles, etc.).

---

6. Errores comunes

· Punteros no inicializados:
  ```c
  int *ptr;  // Peligro: no apunta a una dirección válida.
  *ptr = 5;  // Error! Comportamiento impredecible.
  ```
· Desreferenciar un puntero nulo:
  ```c
  int *ptr = NULL;
  *ptr = 5;  // Segmentation fault!
  ```

---
---
---

## Operador & (Ampersand)

· Obtiene la dirección de memoria de una variable.
· Se usa con variables normales.

Ejemplo:

```c
int num = 10;
printf("Dirección de num: %p", &num);  // &num da la dirección donde está almacenado num
```

---

## Operador * (Asterisco)

Tiene dos usos diferentes:

1. En declaraciones: Indica que una variable es un puntero.
   ```c
   int *ptr;  // ptr es un puntero a entero
   ```
2. En uso con punteros existentes: Accede al valor almacenado en la dirección a la que apunta el puntero (desreferenciación).
   ```c
   int num = 10;
   int *ptr = &num;  // ptr guarda la dirección de num
   printf("Valor: %d", *ptr);  // *ptr da el valor 10 (el contenido de la dirección)
   ```

---

##  Resumen

Operador Se usa con... Función Ejemplo
& Variable normal Obtener dirección de la variable &num → dirección de num
* Puntero declarado Acceder al valor apuntado *ptr → valor almacenado en la dirección que guarda ptr

---

Ejemplo visual para entenderlo mejor

```c
#include <stdio.h>

int main() {
    int num = 10;        // Variable normal
    int *ptr = &num;     // ptr guarda la dirección de num
    
    printf("Valor de num: %d\n", num);           // 10
    printf("Dirección de num: %p\n", &num);      // 0x7ffd42a1c23c (ejemplo)
    printf("Valor de ptr: %p\n", ptr);           // 0x7ffd42a1c23c (misma dirección)
    printf("Valor apuntado por ptr: %d\n", *ptr); // 10 (contenido de esa dirección)
    
    return 0;
}
```

---

Regla mnemotécnica

· & = "Address of" (dirección de)
· * = "Value at" (valor en)

---
---
---
## Punteros y funciones 
Los punteros pueden apuntar a funciones, útil para callbacks o dispatchers.

Ejemplo:

```c
int sumar(int a, int b) { return a + b; }
int restar(int a, int b) { return a - b; }

int main() {
    int (*operacion)(int, int);  // Puntero a función
    operacion = sumar;
    printf("%d\n", operacion(5, 3));  // 8

    operacion = restar;
    printf("%d\n", operacion(5, 3));  // 2
    return 0;
}
```


---

## Pasar argumentos por referencia

En C, los argumentos se pasan por valor (se copia el valor). Si quieres modificar la variable original, debes pasar su dirección memoria usando un puntero.

Ejemplo: Función que modifica una variable

```c
void incrementar(int *a) {
    *a += 1;  // Modifica el valor en la dirección de memoria de 'a'
}

int main() {
    int x = 5;
    incrementar(&x);  // Pasa la dirección de 'x'
    printf("%d", x);  // Imprime 6
    return 0;
}
```

---

## Punteros y arrays

Los arrays se pasan a funciones como punteros (decaimiento a puntero). Esto permite modificar el array original.

Ejemplo: Modificar un array

```c
void llenar_ceros(int *arr, int tamaño) {
    for (int i = 0; i < tamaño; i++) {
        arr[i] = 0;  // Equivale a *(arr + i) = 0
    }
}

int main() {
    int vector[3] = {1, 2, 3};
    llenar_ceros(vector, 3);  // 'vector' decae a puntero
    // vector ahora es {0, 0, 0}
    return 0;
}
```

---

## Retornar punteros desde funciones

Puedes devolver un puntero, pero cuidado: no retornes direcciones de variables locales (se destruyen al salir de la función). Usa memoria dinámica (malloc) o variables estáticas.

Ejemplo correcto con malloc:

```c
int* crear_array(int tamaño) {
    int *arr = (int*)malloc(tamaño * sizeof(int));
    for (int i = 0; i < tamaño; i++) {
        arr[i] = i;
    }
    return arr;  // Retorna puntero a memoria válida
}

int main() {
    int *mi_array = crear_array(5);
    // Usar mi_array...
    free(mi_array);  // ¡Liberar memoria!
    return 0;
}
```

---

## Punteros dobles (**)

Se usan para modificar punteros dentro de funciones o trabajar con arrays de punteros.

Ejemplo: Modificar un puntero

```c
void asignar_memoria(int **p) {
    *p = (int*)malloc(sizeof(int));
    **p = 100;
}

int main() {
    int *ptr = NULL;
    asignar_memoria(&ptr);  // Pasa la dirección del puntero
    printf("%d\n", *ptr);  // Imprime 100
    free(ptr);
    return 0;
}
```

---

## Estructuras con punteros

Para evitar copiar estructuras grandes, pasa su dirección.

Ejemplo:

```c
typedef struct {
    int x;
    int y;
} Punto;

void mover_punto(Punto *p, int dx, int dy) {
    p->x += dx;  // Usar -> para acceder a miembros
    p->y += dy;
}

int main() {
    Punto p = {10, 20};
    mover_punto(&p, 5, 5);
    printf("Nueva posición: (%d, %d)\n", p.x, p.y);  // (15, 25)
    return 0;
}
```

---

## Errores comunes

1. Pasar punteros no inicializados:
   ```c
   int *p;
   *p = 5;  // Error: 'p' no apunta a memoria válida.
   ```
2. Retornar punteros a variables locales:
   ```c
   int* funcion_peligrosa() {
       int x = 10;
       return &x;  // ¡x se destruye al terminar la función!
   }
   ```
3. Olvidar liberar memoria dinámica (memory leaks).

---

Resumen

· Paso por referencia: Usa * para modificar variables originales.
· Arrays: Se pasan como punteros (eficiencia).
· Memoria dinámica: Retorna punteros con malloc (y libera con free).
· Punteros a funciones: Permiten código flexible.
