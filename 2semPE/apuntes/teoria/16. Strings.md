@ingroup apuntes-teoria
## Introducción

En C, los strings son **arrays de caracteres** que finalizan con el carácter nulo `'\0'`. Este carácter especial marca el final de la cadena.

## Representación en Memoria

| Índice | 0   | 1   | 2   | 3   | 4   |
|--------|-----|-----|-----|-----|-----|
| Carácter | H   | O   | L   | A   | \0  |

## Declaración de Strings

```c
/* String con tamaño automático */
char string[] = {0};  // Se adapta al texto asignado

/* String con tamaño fijo */
char string[50] = {0};  // Capacidad para 49 caracteres + \0

/* Inicialización directa */
char saludo[] = "Hola";  // Tamaño: 5 caracteres (incluye \0)
```

> **NOTA:** Inicializar con `{0}` o `""` asegura que no haya "basura" en la memoria.

## Funciones de Manipulación de Strings

### Consideraciones Importantes
- Las funciones sin `n` (como `strcpy`, `strcat`) **no verifican límites** y pueden causar desbordamiento de buffer
- Las funciones con `n` (como `strncpy`, `strncat`) son más seguras pero requieren manejo cuidadoso
- El carácter nulo `\0` no siempre es copiado automáticamente
#### Usar gets y scanf juntos (Limpiar Buffer)

Veamos como leen cada una de ellas la entrada del usuario. Cuando se utiliza la consola, el programa no lee directamente el texto tal cual lo introduce el usuario sino que éste se almacena en una tabla intermedia que llamaremos _buffer_. Cada vez que el usuario pulsa el retorno de carro, se llena el _buffer_ con la línea introducida (incluyendo el carácter `'\n'`). Las diferencias radican en cómo leen las tres funciones del _buffer_. Vamos a verlo con el siguiente ejemplo [Ver mas](https://pablohaya.com/2013/10/12/diferencia-entre-scanf-gets-y-fgets/):

```c
int i1, i2;
char s1[30], s2[30];

scanf("%d", &i1); // 20
scanf("%d", &i2); // 30
// getchar() // limpiar el buffer comiendose el \n 

// fflush(stdin) // limpiar buffer (solo para windows/linux y macOS)

gets(s1); // no dejara escribir porque \n gets lo detecta como dar enter
gets(s2); // pablo
```
##### Limpiar todo el buffer hasta el salto de línea
```c
int c;
while ((c = getchar()) != '\n' && c != EOF);  // Limpia todos los caracteres residuales
```

| **Entrada** | **Buffer antes** | **`Instrucción`**   | **Buffer después** |
| ----------- | ---------------- | ------------------- | ------------------ |
| 20\n        | 20\n             | `scanf("%d", &i1);` | \n                 |
| 30\n        | \n30\n           | `scanf("%d", &i2);` | \n                 |
| \n          | \n               | `gets(s1);`         |                    |
| pablo\n     | pablo\n          | `gets(s2);`         |                    |
1. El primer `scanf` tiene que leer del _buffer_ hasta que encuentra un número (`%d`). En cuanto encuentra el 20 termina de leer, y deja en el _buffer_ un `'\n'`. 
2. El segundo `scanf`, tras la entrada del usuario, se encuentra con `\n30\n`, y tiene que realizar la misma tarea que el anterior, leer un número. Se salta el primer `'\n'`, y lee 30, dejando de nuevo un `'\n'` en el _buffer_. 
3. La función `gets` es más simple, y lo único que hace es leer todo lo que haya en el buffer hasta que encuentre un `'\n'`, y lo copia en la variable correspondiente. Así, el primer `gets` se encuentra un `\n`, lo consume pero no copia nada en `s1`. 
4. El segundo `gets` se encuentra `pablo\n`, así que lee todo lo que hay en el buffer y lo guarda en s2. Para permitir que `pablo` se copie en `s1`.
**Solucion:** incluir una llamada a `getchar()` antes de emplear `gets` para leer `s1`. Esta función lee un carácter del _buffer_, consumiendo así el `'\n'` que impedía rellenar `s1` con `pablo`.
##### ¿Por qué no usar `fflush(stdin)`?
- **Comportamiento indefinido**: El estándar C solo define `fflush` para streams de salida. En algunos compiladores (ej: Windows) puede funcionar, pero en otros (ej: Linux **gcc**) no limpiará el buffer.
- **Falta de portabilidad**: Tu código podría fallar al cambiar de compilador o sistema.
### strcpy() - Copiar string
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strcpy-copy-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strcpy) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcpy-wcscpy-mbscpy?view=msvc-170) | [GNU](https://man.archlinux.org/man/strcpy.3.en)

```c
#include <string.h>

char *strcpy(char *dest, const char *fuent);
```

**Funcionamiento:**
- Copia todos los caracteres de `fuent` (incluyendo `\0`) a `dest`
- **No verifica** el tamaño del buffer destino
- Retorna el puntero `dest`

```c
char destino[20];
char fuente[] = "Hola Mundo";

strcpy(destino, fuente);
// destino = "Hola Mundo"
```

### strncpy() - Copiar string con límite
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strncpy-copy-characters-string) | [CppReference](https://en.cppreference.com/w/c/string/byte/strncpy) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strncpy-strncpy-l-wcsncpy-wcsncpy-l-mbsncpy-mbsncpy-l?view=msvc-170) | [GNU](https://man.archlinux.org/man/strncpy.3.en)

```c
#include <string.h>

char *strncpy(char *dest, const char *fuent, size_t n);
```

**Funcionamiento:**
- Copia hasta `n` caracteres de `fuent` a `dest`
- Si `src` es más corto que `n`, rellena con `\0`
- **No añade `\0` automáticamente** si se copian `n` caracteres

```c
char destino[10];
char fuente[] = "Texto muy largo";

// Copia segura usando sizeof
strncpy(destino, fuente, sizeof(destino) - 1);
destino[sizeof(destino) - 1] = '\0';  // Asegurar terminación

// Ejemplo con límite explícito
strncpy(destino, "ABCDE", 3);
destino[3] = '\0';  // destino = "ABC"
```

### strcat() - Concatenar strings
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strcat-concatenate-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strcat) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat?view=msvc-170) | [GNU](https://man.archlinux.org/man/strcat.3.en)

```c
#include <string.h>

char *strcat(char *dest, const char *fuent);
```

**Funcionamiento:**
- Añade `fuent` al final de `dest`
- Sobrescribe el `\0` de `dest` y añade nuevo `\0` al final
- **Requiere** espacio suficiente en `dest`

```c
char saludo[20] = "Hola";
strcat(saludo, " Mundo");
// saludo = "Hola Mundo"
```

### strncat() - Concatenar strings con límite
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strncat-concatenate-characters-string) | [CppReference](https://en.cppreference.com/w/c/string/byte/strncat) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strncat-strncat-l-wcsncat-wcsncat-l-mbsncat-mbsncat-l?view=msvc-170) | [GNU](https://man.archlinux.org/man/strncat.3.en)

```c
#include <string.h>

char *strncat(char *dest, const char *fuent, size_t n);
```

**Funcionamiento:**
- Añade hasta `n` caracteres de `src` a `fuent`
- **Siempre añade `\0`** al final
- Más seguro que `strcat`

```c
char buffer[15] = "Hola";
strncat(buffer, " Mundo Cruel", 6);
// buffer = "Hola Mundo"
```

### strcmp() - Comparar strings
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strcmp-compare-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strcmp) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcmp-wcscmp-mbscmp?view=msvc-170) | [GNU](https://man.archlinux.org/man/strcmp.3.en)

```c
#include <string.h>

int strcmp(const char *s1, const char *s2);
```

**Funcionamiento:**
- Compara lexicográficamente (orden ASCII)
- **Sensible a mayúsculas/minúsculas**
- Retorna:
  - **< 0** si `s1` < `s2`
  - **0** si `s1` == `s2`
  - **> 0** si `s1` > `s2`

```c
int resultado;

resultado = strcmp("abc", "abc");    // 0 (iguales)
resultado = strcmp("abc", "abd");    // < 0 (abc < abd)
resultado = strcmp("abd", "abc");    // > 0 (abd > abc)
resultado = strcmp("abc", "ABC");    // > 0 (minúsculas > mayúsculas)
```

### strncmp() - Comparar strings con límite
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strncmp-compare-characters-two-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strncmp) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strncmp-strncmp-l-wcsncmp-wcsncmp-l-mbsncmp-mbsncmp-l?view=msvc-170) | [GNU](https://man.archlinux.org/man/strncmp.3.en)

```c
#include <string.h>

int strncmp(const char *s1, const char *s2, size_t n);
```

**Funcionamiento:**
- Compara hasta `n` caracteres
- Útil para comparar prefijos

```c
int resultado;

resultado = strncmp("abcdef", "abcxyz", 3);  // 0 (primeros 3 iguales)
resultado = strncmp("abcdef", "abcxyz", 4);  // < 0 (d != x)
```

## Buenas Prácticas

1. **Usar funciones `n`** para mayor seguridad
2. **Verificar tamaños** antes de operaciones
3. **Asegurar terminación** con `\0`
4. **Usar `sizeof()`** para buffers estáticos

```c
// Ejemplo seguro
char buffer[50];

// Copia segura
strncpy(buffer, texto, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';

// Concatenación segura
if (strlen(buffer) + strlen(texto) < sizeof(buffer)) {
    strcat(buffer, texto);
}
```

## Funciones Adicionales Recomendadas

- `strlen()` - Longitud del string
- `strchr()` - Buscar carácter
- `strstr()` - Buscar substring
- `sprintf()` - Formatear string
- `snprintf()` - Formatear string con límite (más seguro)