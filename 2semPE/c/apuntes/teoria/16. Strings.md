@ingroup apuntes-teoria
## Introducción

En C, los strings son **arrays de caracteres** que finalizan con el carácter nulo `'\0'`. Este carácter especial marca el final de la cadena.

## Representación en Memoria

| Índice | 0   | 1   | 2   | 3   | 4   |
|--------|-----|-----|-----|-----|-----|
| Carácter | H   | O   | L   | A   | \0  |

## Declaración de Strings

```c
/* String con tamaño automático */
char string[] = {0};  // Se adapta al texto asignado

/* String con tamaño fijo */
char string[50] = {0};  // Capacidad para 49 caracteres + \0

/* Inicialización directa */
char saludo[] = "Hola";  // Tamaño: 5 caracteres (incluye \0)
```

> **NOTA:** Inicializar con `{0}` o `""` asegura que no haya "basura" en la memoria.

## Funciones de Manipulación de Strings

### Consideraciones Importantes
- Las funciones sin `n` (como `strcpy`, `strcat`) **no verifican límites** y pueden causar desbordamiento de buffer
- Las funciones con `n` (como `strncpy`, `strncat`) son más seguras pero requieren manejo cuidadoso
- El carácter nulo `\0` no siempre es copiado automáticamente

### strcpy() - Copiar string
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strcpy-copy-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strcpy) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcpy-wcscpy-mbscpy?view=msvc-170) | [GNU](https://man.archlinux.org/man/strcpy.3.en)

```c
#include <string.h>

char *strcpy(char *dest, const char *fuent);
```

**Funcionamiento:**
- Copia todos los caracteres de `fuent` (incluyendo `\0`) a `dest`
- **No verifica** el tamaño del buffer destino
- Retorna el puntero `dest`

```c
char destino[20];
char fuente[] = "Hola Mundo";

strcpy(destino, fuente);
// destino = "Hola Mundo"
```

### strncpy() - Copiar string con límite
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strncpy-copy-characters-string) | [CppReference](https://en.cppreference.com/w/c/string/byte/strncpy) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strncpy-strncpy-l-wcsncpy-wcsncpy-l-mbsncpy-mbsncpy-l?view=msvc-170) | [GNU](https://man.archlinux.org/man/strncpy.3.en)

```c
#include <string.h>

char *strncpy(char *dest, const char *fuent, size_t n);
```

**Funcionamiento:**
- Copia hasta `n` caracteres de `fuent` a `dest`
- Si `src` es más corto que `n`, rellena con `\0`
- **No añade `\0` automáticamente** si se copian `n` caracteres

```c
char destino[10];
char fuente[] = "Texto muy largo";

// Copia segura usando sizeof
strncpy(destino, fuente, sizeof(destino) - 1);
destino[sizeof(destino) - 1] = '\0';  // Asegurar terminación

// Ejemplo con límite explícito
strncpy(destino, "ABCDE", 3);
destino[3] = '\0';  // destino = "ABC"
```

### strcat() - Concatenar strings
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strcat-concatenate-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strcat) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat?view=msvc-170) | [GNU](https://man.archlinux.org/man/strcat.3.en)

```c
#include <string.h>

char *strcat(char *dest, const char *fuent);
```

**Funcionamiento:**
- Añade `fuent` al final de `dest`
- Sobrescribe el `\0` de `dest` y añade nuevo `\0` al final
- **Requiere** espacio suficiente en `dest`

```c
char saludo[20] = "Hola";
strcat(saludo, " Mundo");
// saludo = "Hola Mundo"
```

### strncat() - Concatenar strings con límite
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strncat-concatenate-characters-string) | [CppReference](https://en.cppreference.com/w/c/string/byte/strncat) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strncat-strncat-l-wcsncat-wcsncat-l-mbsncat-mbsncat-l?view=msvc-170) | [GNU](https://man.archlinux.org/man/strncat.3.en)

```c
#include <string.h>

char *strncat(char *dest, const char *fuent, size_t n);
```

**Funcionamiento:**
- Añade hasta `n` caracteres de `src` a `fuent`
- **Siempre añade `\0`** al final
- Más seguro que `strcat`

```c
char buffer[15] = "Hola";
strncat(buffer, " Mundo Cruel", 6);
// buffer = "Hola Mundo"
```

### strcmp() - Comparar strings
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strcmp-compare-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strcmp) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcmp-wcscmp-mbscmp?view=msvc-170) | [GNU](https://man.archlinux.org/man/strcmp.3.en)

```c
#include <string.h>

int strcmp(const char *s1, const char *s2);
```

**Funcionamiento:**
- Compara lexicográficamente (orden ASCII)
- **Sensible a mayúsculas/minúsculas**
- Retorna:
  - **< 0** si `s1` < `s2`
  - **0** si `s1` == `s2`
  - **> 0** si `s1` > `s2`

```c
int resultado;

resultado = strcmp("abc", "abc");    // 0 (iguales)
resultado = strcmp("abc", "abd");    // < 0 (abc < abd)
resultado = strcmp("abd", "abc");    // > 0 (abd > abc)
resultado = strcmp("abc", "ABC");    // > 0 (minúsculas > mayúsculas)
```

### strncmp() - Comparar strings con límite
**Documentación:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-strncmp-compare-characters-two-strings) | [CppReference](https://en.cppreference.com/w/c/string/byte/strncmp) | [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strncmp-strncmp-l-wcsncmp-wcsncmp-l-mbsncmp-mbsncmp-l?view=msvc-170) | [GNU](https://man.archlinux.org/man/strncmp.3.en)

```c
#include <string.h>

int strncmp(const char *s1, const char *s2, size_t n);
```

**Funcionamiento:**
- Compara hasta `n` caracteres
- Útil para comparar prefijos

```c
int resultado;

resultado = strncmp("abcdef", "abcxyz", 3);  // 0 (primeros 3 iguales)
resultado = strncmp("abcdef", "abcxyz", 4);  // < 0 (d != x)
```

## Buenas Prácticas

1. **Usar funciones `n`** para mayor seguridad
2. **Verificar tamaños** antes de operaciones
3. **Asegurar terminación** con `\0`
4. **Usar `sizeof()`** para buffers estáticos

```c
// Ejemplo seguro
char buffer[50];

// Copia segura
strncpy(buffer, texto, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';

// Concatenación segura
if (strlen(buffer) + strlen(texto) < sizeof(buffer)) {
    strcat(buffer, texto);
}
```

## Funciones Adicionales Recomendadas

- `strlen()` - Longitud del string
- `strchr()` - Buscar carácter
- `strstr()` - Buscar substring
- `sprintf()` - Formatear string
- `snprintf()` - Formatear string con límite (más seguro)