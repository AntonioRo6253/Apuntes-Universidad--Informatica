@ingroup apuntes-teoria

---

# Funciones Utiles
>**NOTA:** las librerias de `c` que estan disponibles en `C++` no terminan en `.h`
### Convenciones de nomenclatura para funciones en C

La siguiente tabla resume el significado de los diferentes patrones de nombres que encontré, con base en la documentación oficial.

| Patrón de Nombre                   | Significado / Uso                                                                                                               | Fundamentos Oficiales                                                                                                                                 |
| :--------------------------------- | :------------------------------------------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`ejemplo()`**                    | Función estándar, nombre común.                                                                                                 | Convención común y general.                                                                                                                           |
| **`ejemplo_s()`**                  | "Versión segura" (ej. `printf_s`). No es una convención universal de C, sino una extensión de Microsoft.                        | Extensión de [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/security-features-in-the-crt?view=msvc-170) para funciones seguras . |
| **`ejemplo_i(), ejemplo_p()`**     | "Versión personalizada". No es una regla estricta; el sufijo lo define el autor de la biblioteca para funcionalidad específica. | Convención común para versiones personalizadas .                                                                                                      |
| **`_ejemplo()`** **`_ejemplo()_`** | Nombre reservado. Identificadores de sistema (funciones, variables globales). **No uses** en tu programa.                       | Nombres con un `_` son reservados [GNU/glibc](https://sourceware.org/glibc/manual/latest/html_node/Reserved-Names.html).                              |
| **`__ejemplo()`**                  | Nombre reservado. Identificadores absolutos (macros, constantes). **No uses** en tu programa.                                   | Nombres con doble `__` o `_` y mayúscula son reservados [GNU/glibc](https://sourceware.org/glibc/manual/latest/html_node/Reserved-Names.html).        |
## Printf()
**Documentacion:** [Microsoft](https://learn.microsoft.com/es-es/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=msvc-170) | [IBM](https://www.ibm.com/docs/es/i/7.6.0?topic=functions-printf-print-formatted-characters) | [cppReference](https://en.cppreference.com/w/c/io/fprintf.html) | [GNU/man](https://man.archlinux.org/man/printf.1)

Sirve para imprimir datos en consola
```c
#include <stdio.h>

// printf("Mi Texto");
printf("Hola Mundo");
// printf("%tipo",variable);
printf("%d",num);
// printf("Mi Variable_1 es:%tipo1  Mi Variable_2 es:%tipo2",variable1);
printf("Numero:%d Texto:%s",num,text);
```
**Resultado**
Hola Mundo!

>**NOTA:** Puedes poner casi cualquier accion dentro de la variable que imprimes por ejemplo:
```c
printf("Numero:%d",5*2);
printf("Numero:%d",num[i]);//Arreglo + Ciclo
```
### Marcas
Las marcas es lo que esta después de `%` su estructura es:
`{c}%[parameter][flags][width][.precision][length]type`
**Ejemplo**
```c
#include <stdio.h>

int main() {
    int cantidad = 42;
    double precio = 123.456789;
    char producto[] = "Laptop";

    // Uso completo del formato:
    // %[1$][-][10][.2][lf]
    // donde:
    // [1$] = parameter (posición)
    // [-]  = flag (alineación izquierda)
    // [10] = width (ancho mínimo)
    // [.2] = precision (2 decimales)
    // [l]  = length (long double, aunque aquí es double)
    // [f]  = type (número flotante)

    printf("Producto: %-15s Cantidad: %3d Precio: %8.2f\n", producto, cantidad, precio);

    return 0;
}
```
**Resultado**
Producto: Laptop Cantidad: 42 Precio: 123.46

### Tipos de Datos en las marcas

| Type       | Descripción                                                               |
| ---------- | ------------------------------------------------------------------------- |
| `%c`       | Imprime el carácter ASCII correspondiente                                 |
| `%d`, `%i` | Conversión decimal con signo de un entero                                 |
| `%p`       | Dirección de memoria (puntero)                                            |
| `%e`, `%E` | Conversión a coma flotante con signo en notación científica               |
| `%f`, `%F` | Conversión a coma flotante con signo, usando punto decimal                |
| `%g`, `%G` | Conversión a coma flotante, usando la notación que requiera menor espacio |
| `%o`       | Conversión octal sin signo de un entero                                   |
| `%u`       | Conversión decimal sin signo de un entero                                 |
| `%s`       | Cadena de caracteres (terminada en '\0')                                  |
| `%%`       | Imprime el símbolo %                                                      |

- [Definicion,Estructura,Flags,width,Lenght,types](https://www.it.uc3m.es/pbasanta/asng/course_notes/input_output_printf_es.html)

---

## Scanf()
Sirve para leer datos y guardarlos en una variable
```c
#include <stdio.h>

// Variable
scanf("%d",&num);
// Arreglo
scanf("%4s",array);
```
- **Se parece a Printf():**
	
	  las _marcas(**%d**)_ funcionan casi igual solo que de manera mas limitada

- **Peligro con cadenas**:
	  Usar `%s` es peligroso porque no limita la cantidad de caracteres que se leen, lo que puede causar desbordamientos de búfer si el usuario escribe más caracteres de los que el array puede almacenar.
- **Especificar anchos**:
	  Para evitar desbordamientos, se debe especificar un ancho máximo en la cadena de formato, por ejemplo, `%10s` para leer un máximo de 10 caracteres.

---
## puts()
**Documentacion:** [Microsoft](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/puts-putws?view=msvc-170) | [IBM](https://www.ibm.com/docs/es/i/7.6.0?topic=functions-puts-write-string#puts) |[cppReference](https://en.cppreference.com/w/c/io/puts.html) | [GNU/man](https://man.archlinux.org/man/puts.n)

Imprime una cadena de texto seguida de un salto de línea automático
```c
#include <stdio.h>

char texto[] = "Hola Mundo";
puts(texto);        // Equivalente a: printf("Hola Mundo\n");
puts("Hola Mundo"); // También acepta literales directamente
```
**Ventajas:**
- Más eficiente que `printf` para imprimir cadenas simples
- Añade automáticamente `\n` al final

**Desventajas:**
- Solo funciona con cadenas de texto
- No permite formato personalizado

---
## fgets()
**Documentacion:** [Microsoft](https://www.ibm.com/docs/es/i/7.6.0?topic=functions-fgets-read-string) | [IBM](https://www.ibm.com/docs/es/i/7.6.0?topic=functions-fgets-read-string#fgets) |[cppReference](https://en.cppreference.com/w/c/io/fgets.html) | [GNU/man](https://man.archlinux.org/man/fgets.3)

lee caracteres de la posición actual de ruta hasta el primer carácter de nueva línea `(\n)`, hasta el final de la ruta o hasta que el número de caracteres leídos sea igual a n-1, lo que ocurra primero. La función `fgets()` almacena el resultado en serie y añade un carácter nulo `(\0)` al final de la serie. La serie incluye el carácter de nueva línea, si se lee. Si n es igual a 1, la serie está vacía.
```c
#include <stdio.h>

char fgets(char *str, int n, FILE *stream)
/*
* STR - Es la variable en la que se almacenará la cadena
* N - Es la longitud máxima de la cadena la que se debe leer
* STREAM - Es el identificador del archivo, desde donde se leerá la cadena.
*/
```
---

## gets()
**Documentacion:** [IBM](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-gets-read-line#gets__title__4) | [Microsoft](https://www.ibm.com/docs/es/i/7.5.0?topic=functions-gets-read-line#gets__title__4) |[cppReference](https://en.cppreference.com/w/c/io/gets.html) | [GNU/man](https://man.archlinux.org/man/gets.3.es)

**Deprecada desde C11 - NO USAR**  
Lee una línea completa de entrada estándar hasta encontrar un salto de línea, fue remplazada por `fgets()`
```c
#include <stdio.h>

char cadena[100];
gets(cadena); // ¡PELIGROSO! No verifica límites del buffer
```

**Problemas críticos:**
- No verifica el tamaño del buffer
- Puede causar desbordamiento de buffer
- Eliminado de los estándares modernos de C

**Alternativa segura:**
```c
char cadena[100];
fgets(cadena, sizeof(cadena), stdin);
// fgets incluye el \n al final, gets() no lo incluye
```

---

## fflush()
**Documentacion:**  [IBM](https://www.ibm.com/docs/es/i/7.6.0?topic=functions-fflush-write-buffer-file) | [Microsoft](https://learn.microsoft.com/es-es/cpp/c-runtime-library/reference/fflush?view=msvc-170) | [cppReference](https://en.cppreference.com/w/c/io/fflush.html) | [GNU/man](https://man.archlinux.org/man/fflush.3)

Limpia el buffer de un stream de salida
```c
#include <stdio.h>

printf("Ingrese su nombre: ");
fflush(stdout); // Fuerza la impresión inmediata

// También se usa con archivos
FILE *archivo = fopen("datos.txt", "w");
fprintf(archivo, "Datos importantes");
fflush(archivo); // Fuerza escritura inmediata en disco
```

**Usos comunes:**
- `fflush(stdout)` - Para mostrar output inmediatamente
- `fflush(stdin)` - **Comportamiento indefinido**, no usar
- `fflush(archivo)` - Guardar datos antes de cerrar

---
## strlen()
**Documentacion:** [IBM](https://www.ibm.com/docs/en/zos/3.2.0?topic=functions-strlen-determine-string-length) | [Microsoft](https://learn.microsoft.com/es-es/kusto/query/strlen-function?view=microsoft-fabric) | [cppReference](https://en.cppreference.com/w/c/string/byte/strlen.html) | [GNU/man](https://man.archlinux.org/man/strlen.3)

Devuelve la longitud de un string
```c
#include  <string.h>

print length = strlen("hello");
// 5
```

---

## sizeof()
**Documentacion:**  [Microsoft](https://learn.microsoft.com/es-es/cpp/c-language/sizeof-operator-c?view=msvc-170) | [IBM](https://www.ibm.com/docs/es/i/7.6.0?topic=expressions-sizeof-operator) | [cppReference](https://en.cppreference.com/w/c/language/sizeof.html) |  [GNU](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Type-Size.html)

Devuelve el tamaño en bytes de un tipo de dato o variable
```c
// No necesita librería especial - es un operador del compilador

int numero;
char letra;
double decimal;
int arreglo[10];

printf("Tamaño de int: %zu bytes\n", sizeof(int));
printf("Tamaño de numero: %zu bytes\n", sizeof(numero));
printf("Tamaño de char: %zu bytes\n", sizeof(letra));
printf("Tamaño de double: %zu bytes\n", sizeof(decimal));
printf("Tamaño del arreglo: %zu bytes\n", sizeof(arreglo));
printf("Elementos en arreglo: %zu\n", sizeof(arreglo)/sizeof(arreglo[0]));
```

**Características importantes:**
- Es un operador en tiempo de compilación, no una función
- Devuelve tipo `size_t` (usar `%zu` en printf)
- Muy útil para calcular tamaños de arrays
- No funciona con arrays pasados como parámetros a funciones

## Biblioteca de manipulación de caracteres
**Documentación:**  [IBM - Character handling functions](https://www.ibm.com/docs/en/informix-servers/14.10.0?topic=types-character-string-library-functions ) | [Microsoft - Character classification](https://learn.microsoft.com/en-us/cpp/c-runtime-library/character-classification?view=msvc-170) | [cppReference - Character handling](https://en.cppreference.com/w/c/string/byte) |  [GNU Manual - ctype.h](https://www.gnu.org/software/libc/manual/html_node/Classification-of-Characters.html)


**Libreria:**
```c
#include  <ctype.h>
```

| Prototipo               | Descripcion de la funcion                                                                                                                  | Pagina de Deitel |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | :--------------: |
| `int isdigit( int c );` | Devuelve un valor verdadero si c es un dígito; de lo contrario devuelve 0 (falso).                                                         |                  |
| `int isalpha( int c );` | Devuelve un valor verdadero si c es una letra; de lo contrario devuelve 0 (falso).                                                         |                  |
| `int tolower( int c );` | Si c es una letra mayúscula, tolower devuelve c como una letra minúscula. De lo contrario, tolower devuelve el argumento sin modificación. |       290        |
| `int toupper( int c );` | Si c es una letra minúscula, toupper devuelve c como una letra mayúscula. De lo contrario, toupper devuelve el argumento sin modificación. |                  |

| Prototipo                        | Descripcion de la funcion          | Pagina de Deitel |
| -------------------------------- | ---------------------------------- | :--------------: |
| int atoi( const char *ptrN );    | Convierte la cadena ptrN a int.    |       295        |
| double atof( const char *ptrN ); | Convierte la cadena ptrN a double. |                  |

| Prototipo                   | Descripcion de la funcion                                                                                                                                                                           | Pagina de Deitel |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------: |
| int getchar( void );        | Lee el siguiente carácter de la entrada estándar y lo devuelve como un entero.                                                                                                                      |       299        |
| int putchar( int c );       | Imprime el carácter almacenado en c                                                                                                                                                                 |                  |
| int getchar( void );        | Lee el siguiente carácter de la entrada estándar y lo devuelve como un entero.                                                                                                                      |                  |
| int putchar( int c );       | Imprime el carácter almacenado en c.                                                                                                                                                                |                  |
| char *gets( char *s ) ;     | Lee el siguiente carácter de la entrada estándar y lo coloca en el arreglo s hasta que encuentra un carácter de nueva línea o de fin de archivo. Agrega un carácter de terminación nulo al arreglo. |                  |
| int puts( const char *s ) ; | Imprime la cadena s seguida por el carácter de nueva línea                                                                                                                                          |                  |

| Prototipo                       | Descripcion de la funcion                                                                                            | Pagina de Deitel |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------------- | :--------------: |
| size_t strlen( const char *s ); | Determina la longitud de la cadena s. Devuelve el número de caracteres que preceden al carácter de terminación nulo. |       316        |