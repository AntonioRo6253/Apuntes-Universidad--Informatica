@ingroup apuntes-teoria

# Memoria Dinámica

Ahora que ya conocemos que es un `Array[]`, como acceder al valor de la memoria con `*` y a la dirección de la memoria con `&`. Te resumiré como tener **memoria dinámica** en tu programa.

## ¿Que Es?
Es una forma de **asignar memoria durante la ejecución** del programa, permitiendo crear estructuras de datos cuyo tamaño puede determinarse en tiempo de ejecución y modificarse según sea necesario.

## Comportamientos Visuales
### Mapa de Memoria - Donde se Almacena
![[Captura de pantalla_2025-09-29_22-04-59.png]]
Programación en C, C++, Java y UML, 2da Edición_Luis Joyales, pagina_223
```c
/* ESTRUCTURA DE LA MEMORIA EN C:
 * 
 * 1. SEGMENTO DE CÓDIGO:   Instrucciones del programa
 * 2. SEGMENTO DE DATOS:    Variables globales y estáticas  
 * 3. PILA (Stack):         Variables locales y información de control
 * 4. MONTÍCULO (Heap):     Memoria dinámica (malloc, calloc, realloc)
 * 
 * La memoria dinámica se asigna desde el MONTÍCULO/ALMACÉN LIBRE
 */
```
### Comportamiento de malloc()
![[Pasted image 20250930132102.png]]
Programación en C, C++, Java y UML, 2da Edición_Luis Joyales, pagina_224


**Arreglo Común/Estático**
```c
// Tiene un tamaño fijo de 3 elementos definido en tiempo de compilación
int array[3] = {0,0,0};  // No puede cambiar su tamaño
```

**Arreglo Dinámico**
```c
// El tamaño se determina y puede modificarse durante la ejecución
int *ptrArray;
int tamaño = 3;

// Asignar memoria para 5 enteros
ptrArray = (int*)malloc(tamaño * sizeof(int));

// Si necesitamos más espacio, podemos redimensionar
tamaño = 10;
ptrArray = (int*)realloc(ptrArray, tamaño * sizeof(int));
```

> **NOTA:**
> Si se utiliza una variable en la expresión que determina la longitud de un arreglo para intentar tener **memoria dinámica**, se producirá un _**ERROR**_ en versiones menores a **C99**.
```c 
/* Error */
int n; // variable
… scanf("%d", &n);
char str[n]; // Array
```

## Funciones Principales para Memoria Dinámica

### Sintaxis General
>**NOTA:**
> Si hay un ***error** en la asignación, en cualquier `funcionMemoria()` esta retornará `NULL`.

- Array con índices **automáticos**
```c
//   Puntero |  tipo*  | funcionMemoria(TamañoBytesDelDato)
long* p = (long*) malloc(32);
```
Resultado
```c
long array[ ] = {0};
```

- Array con índice **definido**
```c
//   Puntero |  tipo*  | funcionMemoria(indiceArray * TamañoBytesDelDato)
   long *ptr = (long*)               malloc(5 * 32);
```
Resultado
```c
long array[5] = {0};
```

### Funciones utiles
#### `sizeof(tipoDeDato)`
Se utiliza con mucha frecuencia en las funciones de asignación de memoria. El operador se aplica a un tipo de dato (o una variable), el valor resultante es el número de bytes que ocupa. Asi, si se quiere reservar memoria para un buffer de 10 enteros.
```c
int *puntero;
puntero = (int*) malloc(10*sizeof(int));
```
### puts("")
imprime strings
```c
puts("\nIntroducir una línea de texto\n");
```
#### gets()
```c
/* Pendiente */
```
### malloc() - Asignar memoria
Si un bloque del tamaño solicitado está disponible, `malloc( )` devuelve un apuntador
al principio de un bloque de memoria del tamaño especificado. **Si no hay bastante espacio de almacenamiento** dinámico para cumplir la petición, `malloc( )` devuelve `0` o `NULL`.
```c
// Asigna memoria sin inicializar
int *ptr = (int*)malloc(10 * sizeof(int)); // sizeof(tipoDato) nos da el tamaño en bytes del tipo de dato
```

### calloc() - Asignar e inicializar a cero
```c
// Asigna memoria e inicializa todos los bytes a 0
int *ptr = (int*)calloc(10, sizeof(int));
```

### realloc() - Redimensionar memoria
```c
// Cambia el tamaño del bloque de memoria previamente asignado
ptr = (int*)realloc(ptr, 20 * sizeof(int));
```

### free() - Liberar memoria
```c
// Libera la memoria asignada (IMPORTANTE: evitar fugas de memoria)
free(ptr);
ptr = NULL;  // Buena práctica: asignar NULL después de liberar
```

## ¿Como Usarlo?

### Patrón Básico de Asignación
```c
// 1. Calcular el tamaño necesario
// 2. Asignar memoria
// 3. Verificar éxito de la asignación
// 4. Usar la memoria
// 5. Liberar cuando ya no se necesite

tipo* puntero = (tipo*)malloc(cantidad * sizeof(tipo));
if (puntero == NULL) {
    // Manejar error de asignación de manera robusta
    fprintf(stderr, "Error crítico: No se pudo asignar memoria\n");
    exit(EXIT_FAILURE);  // Salir del programa inmediatamente
}
```

### Ejemplo Completo
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    int *arr;
    
    // Solicitar tamaño al usuario
    printf("Ingrese el tamaño del arreglo: ");
    scanf("%d", &n);
    
    // Asignar memoria dinámica
    arr = (int*)malloc(n * sizeof(int));
    
    if (arr == NULL) {
        printf("Error: No se pudo asignar memoria\n");
        return 1;
    }
    
    // Usar el arreglo
    for (int i = 0; i < n; i++) {
        arr[i] = i * 2;
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    // Liberar memoria
    free(arr);
    
    return 0;
}
```

## Programa para Probar Límites de Memoria
```c
#include <stdio.h>
#include <stdlib.h>

// Función para determinar cuánta memoria se puede asignar
void probarLimitesMemoria() {
    void *p;
    int i;
    long memoria_total = 0;
    
    printf("Probando límites de memoria disponible...\n");
    
    for (i = 1; ; i++) {
        p = malloc(1000);  // Intentar asignar 1000 bytes
        if (p == NULL) {
            printf("¡Memoria agotada en el intento %d!\n", i);
            break;
        }
        memoria_total += 1000;
    }
    
    printf("Memoria máxima asignable: %ld bytes (%.2f KB)\n", 
           memoria_total, memoria_total / 1024.0);
}

int main() {
    probarLimitesMemoria();
    return 0;
}
```

## Arrays Multidimensionales Dinámicos

### Matriz Bidimensional Dinámica
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int **matriz;
    int filas, columnas, i, j;
    
    // Solicitar dimensiones al usuario
    printf("Número de filas: ");
    scanf("%d", &filas);
    printf("Número de columnas: ");
    scanf("%d", &columnas);
    
    // Reservar memoria para el array de punteros a filas
    matriz = (int**)malloc(filas * sizeof(int*));
    if (matriz == NULL) {
        fprintf(stderr, "Error: No se pudo asignar memoria para filas\n");
        exit(EXIT_FAILURE);
    }
    
    // Reservar memoria para cada fila
    for (i = 0; i < filas; i++) {
        matriz[i] = (int*)malloc(columnas * sizeof(int));
        if (matriz[i] == NULL) {
            fprintf(stderr, "Error: No se pudo asignar memoria para fila %d\n", i);
            exit(EXIT_FAILURE);
        }
    }
    
    // Inicializar y mostrar la matriz
    printf("\nMatriz %dx%d:\n", filas, columnas);
    for (i = 0; i < filas; i++) {
        for (j = 0; j < columnas; j++) {
            matriz[i][j] = i * 10 + j;  // Valor ejemplo
            printf("%3d ", matriz[i][j]);
        }
        printf("\n");
    }
    
    // Liberar memoria (IMPORTANTE: liberar en orden inverso)
    for (i = 0; i < filas; i++) {
        free(matriz[i]);  // Liberar cada fila
    }
    free(matriz);  // Liberar el array de punteros
    
    return 0;
}
```

### Estructuras con Memoria Dinámica
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definición de una estructura compleja
struct Persona {
    char *nombre;    // Memoria dinámica para nombre
    int edad;
    float altura;
};

int main() {
    int n, i;
    struct Persona *grupo;
    
    printf("Número de personas: ");
    scanf("%d", &n);
    
    // Reservar memoria para el array de estructuras
    grupo = (struct Persona*)malloc(n * sizeof(struct Persona));
    if (grupo == NULL) {
        fprintf(stderr, "Error crítico: Memoria insuficiente\n");
        exit(EXIT_FAILURE);
    }
    
    // Inicializar cada persona
    for (i = 0; i < n; i++) {
        char buffer[100];
        
        printf("\nPersona %d:\n", i+1);
        printf("Nombre: ");
        scanf("%s", buffer);
        
        // Reservar memoria dinámica para el nombre
        grupo[i].nombre = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
        if (grupo[i].nombre == NULL) {
            fprintf(stderr, "Error: No se pudo asignar memoria para el nombre\n");
            exit(EXIT_FAILURE);
        }
        strcpy(grupo[i].nombre, buffer);
        
        printf("Edad: ");
        scanf("%d", &grupo[i].edad);
        printf("Altura: ");
        scanf("%f", &grupo[i].altura);
    }
    
    // Mostrar los datos
    printf("\n--- Datos ingresados ---\n");
    for (i = 0; i < n; i++) {
        printf("Persona %d: %s, %d años, %.2f m\n", 
               i+1, grupo[i].nombre, grupo[i].edad, grupo[i].altura);
    }
    
    // Liberar memoria (IMPORTANTE: liberar en orden)
    for (i = 0; i < n; i++) {
        free(grupo[i].nombre);  // Liberar cada nombre
    }
    free(grupo);  // Liberar el array de estructuras
    
    return 0;
}
```

## Buenas Prácticas

1. **Siempre verificar** si malloc/calloc/realloc retornan NULL
2. **Usar `exit(EXIT_FAILURE)`** para errores graves de memoria
3. **Liberar la memoria** con free() cuando ya no se necesite
4. **Asignar NULL** después de liberar para evitar punteros colgantes
5. **No acceder a memoria** después de liberarla
6. **Liberar en orden inverso** a la asignación para estructuras complejas

## Nota sobre Arreglos de Longitud Variable (VLA) C99

```c
// A partir de C99, esto ES válido (pero tiene limitaciones)
int n;
scanf("%d", &n);
char str[n];  // VLA - Arreglo de Longitud Variable

// Limitaciones de los VLA:
// - Solo existen en el ámbito donde se declaran
// - No se pueden redimensionar
// - Tamaño limitado al tamaño de la pila
```

## Errores Comunes y Cómo Evitarlos

### 1. Fuga de Memoria (Memory Leak)
```c
// MAL: Memoria nunca liberada
void funcion() {
    int *ptr = (int*)malloc(100 * sizeof(int));
    // ... usar ptr ...
    // OLVIDO: free(ptr);
}

// BIEN: Siempre liberar
void funcion() {
    int *ptr = (int*)malloc(100 * sizeof(int));
    if (ptr == NULL) {
        fprintf(stderr, "Error de asignación\n");
        return;
    }
    
    // ... usar ptr ...
    
    free(ptr);
}
```

### 2. Acceso a Memoria Liberada
```c
// MAL: Acceso después de free()
int *ptr = (int*)malloc(sizeof(int));
*ptr = 10;
free(ptr);
printf("%d", *ptr);  // COMPORTAMIENTO INDEFINIDO

// BIEN: Asignar NULL después de free
free(ptr);
ptr = NULL;
```

### 3. Liberación Doble
```c
// MAL: Liberar dos veces
free(ptr);
free(ptr);  // ERROR

// BIEN: Verificar antes de liberar
if (ptr != NULL) {
    free(ptr);
    ptr = NULL;
}
```

## Practicas

- Matriz Dinámica Bidimensional
- Estructuras con campos de memoria dinámica
- Programas que prueben límites de memoria
- Gestión de memoria para datos de tamaño variable

## Resumen de Manejo Robusto de Errores

```c
// PATRÓN RECOMENDADO para manejo de errores:
tipo* ptr = (tipo*)malloc(tamaño);
if (ptr == NULL) {
    // Error grave - no continuar
    fprintf(stderr, "Error crítico: sin memoria disponible\n");
    exit(EXIT_FAILURE);  // Terminar el programa inmediatamente
}

// Para errores menos graves:
tipo* ptr2 = (tipo*)calloc(n, sizeof(tipo));
if (ptr2 == NULL) {
    // Intentar recuperación o salir limpiamente
    free(ptr);  // Liberar recursos anteriores
    return ERROR_CODE;  // Retornar código de error
}
```